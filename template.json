{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Competitive Programming Helper": {
		"prefix": "cph",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"using namespace std;",
			"",
			"#define int long long",
			"typedef long double ld;",
			"typedef pair<int, int> pii;",
			"#define pb push_back",
			"#define all(x) x.begin(), x.end()",
			"#define mp make_pair",
			"#define L first",
			"#define R second",
			"#define endl \"\\n\"",
			"",
			"#define fo(i, l, r) for(int i = l; i < r; i++) // denotes open set",
			"#define fc(i, l, r) for(int i = l; i <= r; i++) // denotes closed set",
			"#define rfo(i, l, r) for(int i = r; i > l; i--) // r means reversed",
			"#define rfc(i, l, r) for(int i = r; i >= l; i--) // r means reversed",
			"",
			"signed main() {",
			"\tios::sync_with_stdio(0);",
			"\tcin.tie(0);",
			"\tcout.tie(0);",
			"\t$0",
			"}"
		],
		"description": "stolen macros & functions lol"
	},
	"Prime Check": {
		"prefix": "cphisprime",
		"body": [
			"// Prime check",
			"",
			"bool isPrime(int n) {",
			"\tif (n <= 1) return false;",
			"\tfor (int i = 2; i * i <= n; ++i) {",
			"\t\tif (n % i == 0) return false;",
			"\t}",
			"\treturn true;",
			"}"
		],
		"description": "Creates a code snippet for checking if a number is prime."
	},
	"GCD": {
		"prefix": "cphgcd",
		"body": [
			"// Greatest common divisor",
			"",
			"int gcd(int a, int b) {",
			"\treturn __gcd(a, b);",
			"}"
		],
		"description": "Creates a code snippet for calculating the greatest common divisor using STL."
	},
	"LCM": {
		"prefix": "cphlcm",
		"body": [
			"// Least common multiple",
			"",
			"int lcm(int a, int b) {",
			"\treturn (a / __gcd(a, b)) * b;",
			"}"
		],
		"description": "Creates a code snippet for calculating the least common multiple."
	},
	"Sieve of Eratosthenes": {
		"prefix": "cphsieve",
		"body": [
			"// Sieve of Eratosthenes",
			"",
			"vector<int> sieve(int n) {",
			"\tvector<bool> is_prime(n + 1, true);",
			"\tvector<int> primes;",
			"\tfor (int p = 2; p * p <= n; ++p) {",
			"\t\tif (is_prime[p]) {",
			"\t\t\tfor (int i = p * p; i <= n; i += p)",
			"\t\t\t\tis_prime[i] = false;",
			"\t\t}",
			"\t}",
			"\tfor (int p = 2; p <= n; ++p) {",
			"\t\tif (is_prime[p]) primes.push_back(p);",
			"\t}",
			"\treturn primes;",
			"}"
		],
		"description": "Creates a code snippet for the Sieve of Eratosthenes."
	},
	"Factorize": {
		"prefix": "cphfactorize",
		"body": [
			"// Factorize",
			"",
			"vector<int> factorize(int n) {",
			"\tvector<int> factors;",
			"\tfor (int p = 2; p * p <= n; ++p) {",
			"\t\twhile (n % p == 0) {",
			"\t\t\tfactors.push_back(p);",
			"\t\t\tn /= p;",
			"\t\t}",
			"\t}",
			"\tif (n > 1) factors.push_back(n);",
			"\treturn factors;",
			"}"
		],
		"description": "Creates a code snippet for factorizing a number."
	},
	"Euler's Totient Function": {
		"prefix": "cphphi",
		"body": [
			"// Euler's Totient Function",
			"",
			"int phi(int n) {",
			"\tint result = n;",
			"\tfor (int p = 2; p * p <= n; ++p) {",
			"\t\tif (n % p == 0) {",
			"\t\t\twhile (n % p == 0) n /= p;",
			"\t\t\tresult -= result / p;",
			"\t\t}",
			"\t}",
			"\tif (n > 1) result -= result / n;",
			"\treturn result;",
			"}"
		],
		"description": "Creates a code snippet for Euler's Totient Function."
	},
	"Integer Square Root": {
		"prefix": "cphisqrt",
		"body": [
			"// Integer square root",
			"",
			"int isqrt(int n) {",
			"\tint lo = 0, hi = n;",
			"\twhile (lo <= hi) {",
			"\t\tint mid = lo + (hi - lo) / 2;",
			"\t\tif (mid * mid <= n) {",
			"\t\t\tlo = mid + 1;",
			"\t\t} else {",
			"\t\t\thi = mid - 1;",
			"\t\t}",
			"\t}",
			"\treturn lo - 1;",
			"}"
		],
		"description": "Creates a code snippet for integer square root."
	},
	"Ceiling Division": {
		"prefix": "cphdivceil",
		"body": [
			"// Ceiling division",
			"",
			"long long div_ceil(long long a, long long b) {",
			"\treturn (b >= 0 ? (a + b - 1) : a) / b;",
			"}"
		],
		"description": "Creates a code snippet for ceiling division."
	},
	"Binary Exponentiation": {
		"prefix": "cphbinpow",
		"body": [
			"// Binary exponentiation",
			"",
			"int binpow(int a, int b) {",
			"\tint r = 1;",
			"\twhile (b) {",
			"\t\tif (b & 1) {",
			"\t\t\tr *= a;",
			"\t\t}",
			"\t\ta *= a;",
			"\t\tb >>= 1;",
			"\t}",
			"\treturn r;",
			"}"
		],
		"description": "Creates a code snippet for binary exponentiation."
	},
	"Graph": {
		"prefix": "cphgraph",
		"body": [
			"struct Graph {",
			"    int vertices;",
			"    vector<vector<int> > adj;",
			"    int edges;",
			"",
			"    Graph(int v) : vertices(v), adj(v), edges(0) {}",
			"",
			"    void addEdge(int u, int v) {",
			"        adj[u].push_back(v);",
			"        adj[v].push_back(u);",
			"        edges++;",
			"    }",
			"",
			"    void addDirectedEdge(int u, int v) {",
			"        adj[u].push_back(v);",
			"        edges++;",
			"    }",
			"",
			"    int getNumVertices() {",
			"        return vertices;",
			"    }",
			"",
			"    int getNumEdges() {",
			"        return edges;",
			"    }",
			"",
			"    void print_graph() {",
			"        cout << \"Graph adjacency list:\" << endl;",
			"        for (int i = 0; i < vertices; ++i) {",
			"            cout << i << \" -> \";",
			"            for (int v : adj[i]) {",
			"                cout << v << \" \";",
			"            }",
			"            cout << endl;",
			"        }",
			"    }",
			"};"
		],
		"description": "Graph struct for competitive programming with methods to get the number of vertices, edges, and print the graph."
	},
	"Iterative DFS": {
		"prefix": "cphdfs",
		"body": [
			"// Iterative DFS",
			"",
			"void iterativeDFS(int start, const vector<vector<int>>& adj) {",
			"\tint n = adj.size();",
			"\tvector<bool> visited(n, false);",
			"\tstack<int> stk;",
			"\tstk.push(start);",
			"",
			"\twhile (!stk.empty()) {",
			"\t\tint node = stk.top();",
			"\t\tstk.pop();",
			"",
			"\t\tif (!visited[node]) {",
			"\t\t\tvisited[node] = true;",
			"",
			"\t\t\tfor (auto it = adj[node].rbegin(); it != adj[node].rend(); ++it) {",
			"\t\t\t\tif (!visited[*it]) {",
			"\t\t\t\t\tstk.push(*it);",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"}"
		],
		"description": "Creates a code snippet for iterative DFS."
	},
	"Iterative BFS": {
		"prefix": "cphbfs",
		"body": [
			"// Iterative BFS",
			"",
			"void iterativeBFS(int start, const vector<vector<int>>& adj) {",
			"\tint n = adj.size();",
			"\tvector<bool> visited(n, false);",
			"\tqueue<int> q;",
			"\tq.push(start);",
			"\tvisited[start] = true;",
			"",
			"\twhile (!q.empty()) {",
			"\t\tint node = q.front();",
			"\t\tq.pop();",
			"",
			"\t\tfor (int neighbor : adj[node]) {",
			"\t\t\tif (!visited[neighbor]) {",
			"\t\t\t\tvisited[neighbor] = true;",
			"\t\t\t\tq.push(neighbor);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"}"
		],
		"description": "Creates a code snippet for iterative BFS."
	},
	"DSU Implementation": {
		"prefix": "cphdsu",
		"body": [
			"const int MAXN = 1000;",
			"",
			"struct DSU {",
			"    vector<int> lst[MAXN];",
			"    int parent[MAXN];",
			"    int set_count;",
			"",
			"    DSU() {",
			"        set_count = 0;",
			"    }",
			"",
			"    void make_set(int v) {",
			"        lst[v] = vector<int>(1, v);",
			"        parent[v] = v;",
			"        set_count++;",
			"    }",
			"",
			"    int find_set(int v) {",
			"        return parent[v];",
			"    }",
			"",
			"    void union_sets(int a, int b) {",
			"        a = find_set(a);",
			"        b = find_set(b);",
			"        if (a != b) {",
			"            if (lst[a].size() < lst[b].size())",
			"                swap(a, b);",
			"            while (!lst[b].empty()) {",
			"                int v = lst[b].back();",
			"                lst[b].pop_back();",
			"                parent[v] = a;",
			"                lst[a].push_back(v);",
			"            }",
			"            set_count--;",
			"        }",
			"    }",
			"",
			"    int size_of_set(int v) {",
			"        return lst[find_set(v)].size();",
			"    }",
			"",
			"    int get_set_count() const {",
			"        return set_count;",
			"    }",
			"",
			"    void print_dsu() {",
			"        cout << \"Disjoint Set Union State:\" << endl;",
			"        for (int i = 0; i < MAXN; ++i) {",
			"            if (!lst[i].empty()) {",
			"                cout << \"Set \" << i << \": \";",
			"                for (int v : lst[i]) {",
			"                    cout << v << \" \";",
			"                }",
			"                cout << endl;",
			"            }",
			"        }",
			"    }",
			"};"
		],
		"description": "Creates a code snippet for DSU implementation with set count and print_dsu method."
	},
	"FenwickTree": {
		"prefix": "cphfenwicktree",
		"body": [
			"struct FenwickTree {",
			"    vector<int> bit; ",
			"    vector<int> original;",
			"    int n;",
			"",
			"    FenwickTree(int n) {",
			"        this->n = n;",
			"        bit.assign(n + 1, 0);       ",
			"        original.assign(n + 1, 0);  ",
			"    }",
			"",
			"    FenwickTree(vector<int> const &a) : FenwickTree(a.size()) {",
			"        original = vector<int>(a.size() + 1, 0);",
			"        for (int i = 1; i <= n; i++) {",
			"            add(i, a[i - 1]); ",
			"        }",
			"    }",
			"",
			"    int sum(int r) {",
			"        int ret = 0;",
			"        for (; r > 0; r -= r & -r)",
			"            ret += bit[r];",
			"        return ret;",
			"    }",
			"",
			"    int sum(int l, int r) {",
			"        return sum(r) - sum(l - 1);",
			"    }",
			"",
			"    void add(int idx, int delta) {",
			"        original[idx] += delta;",
			"        for (; idx <= n; idx += idx & -idx)",
			"            bit[idx] += delta;",
			"    }",
			"",
			"    void pointUpdate(int idx, int newValue) {",
			"        int delta = newValue - original[idx];",
			"        original[idx] = newValue;",
			"        for (; idx <= n; idx += idx & -idx)",
			"            bit[idx] += delta;",
			"    }",
			"",
			"    void print() {",
			"        cout << \"Original vector: \";",
			"        for (int i = 1; i <= n; ++i) {",
			"            cout << original[i] << \" \";",
			"        }",
			"        cout << endl;",
			"",
			"        cout << \"Fenwick Tree: \";",
			"        for (int i = 1; i <= n; ++i) {",
			"            cout << bit[i] << \" \";",
			"        }",
			"        cout << endl;",
			"",
			"        cout << \"Prefix sums paths:\" << endl;",
			"        for (int i = 1; i <= n; ++i) {",
			"            cout << \"bit[\" << i << \"]: \";",
			"            int idx = i;",
			"            int path_sum = 0;",
			"            vector<int> path;",
			"            while (idx > 0) {",
			"                path.push_back(original[idx]);",
			"                path_sum += original[idx];",
			"                idx -= idx & -idx;",
			"            }",
			"            for (int j = path.size() - 1; j >= 0; --j) {",
			"                cout << path[j] << \" \";",
			"            }",
			"            cout << \": \" << path_sum << endl;",
			"        }",
			"    }",
			"};"
		],
		"description": "Creates a code snippet for Fenwick Tree (Binary Indexed Tree) implementation with 1-based indexing."
	},
	"PBDS Indexed Set": {
		"prefix": "cphindexedset",
		"body": [
			"#include <ext/pb_ds/assoc_container.hpp>",
			"using namespace __gnu_pbds;",
			"",
			"typedef tree<int, null_type, less<int>, rb_tree_tag,",
			"             tree_order_statistics_node_update>",
			"    indexed_set;"
		],
		"description": "Creates a code snippet for an indexed set using PBDS."
	},
	"PBDS Indexed Map": {
		"prefix": "cphindexedmap",
		"body": [
			"#include <ext/pb_ds/assoc_container.hpp>",
			"using namespace __gnu_pbds;",
			"",
			"template<typename Key, typename Value>",
			"using indexed_map = tree<Key, Value, less<Key>, rb_tree_tag, tree_order_statistics_node_update>;"
		],
		"description": "Creates a code snippet for an indexed map using PBDS."
	}
}
